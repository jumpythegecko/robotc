#pragma config(Sensor, in6,    L3,             sensorLineFollower)
#pragma config(Sensor, in7,    L2,             sensorLineFollower)
#pragma config(Sensor, in8,    L1,             sensorLineFollower)
#pragma config(Sensor, dgtl1,  sn11,           sensorSONAR_inch)
#pragma config(Sensor, dgtl3,  sn22,           sensorSONAR_inch)
#pragma config(Sensor, dgtl5,  sn33,           sensorSONAR_inch)
#pragma config(Sensor, dgtl7,  sn44,           sensorSONAR_inch)
#pragma config(Sensor, dgtl10, ,               sensorTouch)
#pragma config(Motor,  port6,           handMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           handServo,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           servo1,        tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           motor1,        tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool hdown;
bool hopen;
bool line;
bool us;
bool Bleft;
bool Bright;
bool right;
int servopos;
int dn;
int lineThreshold;
int servoOffsetAngle;
int rightangle;
int leftangle;
float s1;
float s2;
float s3;
float s4;
float l1;
float l2;
float l3;
bool ll1;
bool ll2;
bool ll3;
bool ball;
bool us2;
string lin;
string linP;
int test;
int less = 8;
int more = 11;
int evenMore = 22;


void die(){

}


void ultrasonic2(){
	if(vexRT[Btn8R] == 1){
		us2 = false;
	}
	
	int mSpeed = 32;
	int offset = 60;
	
	s1 = SensorValue[sn11];
	s2 = SensorValue[sn22];
	s4 = SensorValue[sn44];
	
	if(s1<more && s1>less && s4<more && s4>less){
		motor[motor1] = mSpeed;
		motor[servo1] = (servoOffsetAngle)*-1;
	}else if(s1>more || s4<less || (s1>more && s4>more) || s1>evenMore){//right
		motor[motor1] = mSpeed;
		motor[servo1] = (servoOffsetAngle+(offset))*-1;
	} else if(s1<less || s4>more || (s1<less && s4<less)){//left
		motor[motor1] = mSpeed;
		motor[servo1] = (servoOffsetAngle-(offset))*-1;
	}
	
}






task main()
{
	hdown = false;
	hopen = false;
	Bright = true;
	Bleft = false;
	ball = false;
	right = true;
	servopos = 0;
	dn = 1;
	rightangle = 0;
	leftangle = -40;
	us = false;
	line = false;
	ll1 = false;
	ll2 = false;
	ll3 = false;
	lin = "010";
	linP = "010";
	lineThreshold = 2000;
	servoOffsetAngle = 60;
	test = 0;

	while(1 == 1)
	{
		//motor[light] = 100;
		l1 = SensorValue[L1];
		l2 = SensorValue[L2];
		l3 = SensorValue[L3];
		//---------------------------------------------------------------Line_following---------------------------------------------------------------//
		while(line == true){
			if(vexRT[Btn5D] == 1){
				if(line == true){
					line = false;
					delay(250);
					} else {
					line = true;
					delay(250);
				}
			}

			//resets string for holding line sensor values
			if(lin != "000"){
				linP = lin;
			}
			lin = "";

			l1 = SensorValue[L1];     //reads line sensor values
			l2 = SensorValue[L2];
			l3 = SensorValue[L3];

			if(l1>lineThreshold){     //sets the string based on the line sensor values
				lin += "1";
				} else {
				lin += "0";
			}
			if(l2>lineThreshold){
				lin += "1";
				} else {
				lin += "0";
			}
			if(l3>lineThreshold){
				lin += "1";
				} else {
				lin += "0";
			}

			int lineSteer = 100;
			int lineSteer2 = 55;
			int motorSpeed = 30;

			switch(atoi(lin)){     //deciding how to drive with a switch function
			case 000:
				//if none are on black, use previous line value

				test = 1;
				switch(atoi(linP)){
				case 001:
					motor[servo1] = (servoOffsetAngle+lineSteer2)*-1;
					motor[motor1] = motorSpeed;
					break;
				case 010:
					motor[motor1] = motorSpeed;
					motor[servo1] = (servoOffsetAngle)*-1;
					break;
				case 100:
					motor[servo1] = (servoOffsetAngle-lineSteer2)*-1;
					motor[motor1] = motorSpeed;
					break;
				}

				break;
			case 001:
				//go right//
				motor[motor1] = motorSpeed;
				motor[servo1] = (servoOffsetAngle+lineSteer)*-1;
				test = 2;
				break;
			case 010:
				//go forward//
				motor[motor1] = motorSpeed;
				motor[servo1] = (servoOffsetAngle)*-1;
				test = 3;
				break;
			case 011:
				//this should not happen
				test = 4;
				die();
				break;
			case 100:
				//go left//
				motor[motor1] = motorSpeed;
				motor[servo1] = (servoOffsetAngle-lineSteer)*-1;
				test = 5;
				break;
			case 101:
				//this should not happen
				test = 6;
				die();
				break;
			case 110:
				//this should not happen
				test = 7;
				die();
				break;
			case 111:
				//if this happens the universe is broken
				test = 8;
				die();
				break;
			default:
				test = 0;
				motor[motor1] = 0;
				break;
			}
			delay(50);
			motor[motor1] = 0;
			motor[servo1] = (servoOffsetAngle)*-1;
			//delay(25);

		}
		//---------------------------------------------------------------End_Line_Following---------------------------------------------------------------//

		//---------------------------------------------------------------Ultrasonic---------------------------------------------------------------//
		right = true;
		while(us == true){
			if(vexRT[Btn6U] == 1){
				us = false;
			}
			s1 = SensorValue[sn11];
			s2 = SensorValue[sn22];
			s3 = SensorValue[sn33];

			int sonLimS = 4.5;
			int sonLim = 9;
			string sonVals = "";



			if(s3<sonLimS){
				sonVals += "2";
				} else if(s3<sonLim){   //sets the sonarValues string based on the value of the sensors
				sonVals += "1";
				} else {
				sonVals += "0";
			}
			if(s2<sonLimS){
				sonVals += "2";
				} else if(s2<sonLim){
				sonVals += "1";
				} else {
				sonVals += "0";
			}
			if(s1<sonLimS){
				sonVals += "2";
				} else if(s1<sonLim){
				sonVals += "1";
				} else {
				sonVals += "0";
			}

			int slight = 70;
			int hard = 100;
			int motorSpeed = 40;

			switch(atoi(sonVals)){    //moves the robot based on the sonarValues string
			case 000://forward
			case 202:
			case 101:
				motor[motor1] = motorSpeed;
				motor[servo1] = (servoOffsetAngle)*-1;
				break;
			case 001://slight left
			case 011:
			case 102:
			case 112:
				right = false;
				motor[motor1] = motorSpeed;
				motor[servo1] = (servoOffsetAngle-(slight))*-1;
				break;
			case 002://hard left
			case 012:
				right = false;
				motor[motor1] = motorSpeed;
				motor[servo1] = (servoOffsetAngle-(hard))*-1;
				break;
			case 100://slight right
			case 110:
			case 201:
			case 211:
				right = true;
				motor[motor1] = motorSpeed;
				motor[servo1] = (servoOffsetAngle+slight)*-1;
				break;
			case 200://hard right
			case 210:
				right = true;
				motor[motor1] = motorSpeed;
				motor[servo1] = (servoOffsetAngle+hard)*-1;
				break;
			case 022:
			case 122://turn right back
			case 021:
				right = true;
				motor[motor1] = 0;
				delay(250);
				motor[motor1] = motorSpeed*-1;
				motor[servo1] = (servoOffsetAngle-(hard))*-1;
				delay(750);
				motor[motor1] = 0;
				motor[servo1] = (servoOffsetAngle)*-1;
				delay(350);
				break;
			case 220:
			case 221://turn left back
			case 120:
				right = false;
				motor[motor1] = 0;
				delay(250);
				motor[motor1] = motorSpeed*-1;
				motor[servo1] = (servoOffsetAngle+(hard))*-1;
				delay(750);
				motor[motor1] = 0;
				motor[servo1] = (servoOffsetAngle)*-1;
				delay(350);
				break;
			case 111:
			case 010://for all of these values, go back
			case 020:
			case 121:
			case 222:
				motor[motor1] = 0;
				delay(250);
				motor[motor1] = motorSpeed*-1;
				if(right){
					motor[servo1] = (servoOffsetAngle-(hard))*-1;
					} else {
					motor[servo1] = (servoOffsetAngle+(hard))*-1;
				}
				delay(750);
				motor[motor1] = 0;
				motor[servo1] = (servoOffsetAngle)*-1;
				delay(350);
				break;
			}
			delay(50);
			motor[motor1] = 0;
			motor[servo1] = (servoOffsetAngle)*-1;
		}
		//---------------------------------------------------------------End_Ultrasonic---------------------------------------------------------------//

		//---------------------------------------------------------------Joystick_Input---------------------------------------------------------------//
		motor[servo1] = ((vexRT[Ch1] / 2)+servoOffsetAngle)*-1;
		if(vexRT[Btn5U] == 1){
			dn = 3;
			} else {
			dn = 1;
		}
		
		motor[motor1] = vexRT[Ch3]/dn;
		if(vexRT[Btn8L] == 1){
			us2 = true;
		}
		if(vexRT[Btn8R] == 1){
			us2 = false;
		}

		while(us2){
			ultrasonic2();
		}

		if(vexRT[Btn7U] == 1){
			motor[handServo] = 35;
			}else if(vexRT[Btn7D] == 1){
			motor[handServo] = -35;
			} else if(vexRT[Btn8U] == 1){
			motor[handServo] = 127;
			} else if(vexRT[Btn8D] == 1){
			motor[handServo] = -127;
			} else {
			if(ball){
				motor[handServo] = -12;
				} else {
				motor[handServo] = 12;
			}
		}

		if(vexRT[Btn7L] == 1){
			motor[handMotor] = 45;
			}else if(vexRT[Btn7R] == 1){
			motor[handMotor] = -35;
			} else {
			motor[handMotor] = 0;
		}

		if(vexRT[Btn6D] == 1){
			us = true;
		}
		if(vexRT[Btn5D] == 1){
			if(line == true){
				line = false;
				delay(250);
				} else {
				line = true;
				delay(250);
			}
		}
		if(vexRT[Btn6U] == 1){
			ball = true;
			} else {
			ball = false;
		}
	}
}
//---------------------------------------------------------------End_Joystick_Input---------------------------------------------------------------//




























/*
l1 = SensorValue[L1];
l2 = SensorValue[L2];
l3 = SensorValue[L3];
if(l1>lineThreshold){
ll1 = true;
} else {
ll1 = false;
}
if(l2>lineThreshold){
ll2 = true;
} else {
ll2 = false;
}
if(l3>lineThreshold){
ll3 = true;
} else {
ll3 = false;
}

//deciding how to drive

if(ll1){
motor[motor1] = -35;
motor[servo1] = rightangle;
right = true;
left = false;
} else if(ll2){
motor[motor1] = 35;
motor[servo1] = -20;
} else if(ll3){
motor[motor1] = 35;
motor[servo1] = leftangle;
right = false;
left = true;
} else if(right){
motor[motor1] = 35;
motor[servo1] = rightangle;
} else if(left){
motor[motor1] = 35;
motor[servo1] = leftangle;
} else {
motor[motor1] = 0;
motor[servo1] = 0;
}
*/
