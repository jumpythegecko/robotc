#pragma config(Sensor, in6,    L3,             sensorLineFollower)
#pragma config(Sensor, in7,    L2,             sensorLineFollower)
#pragma config(Sensor, in8,    L1,             sensorLineFollower)
#pragma config(Sensor, dgtl1,  sn11,           sensorSONAR_inch)
#pragma config(Sensor, dgtl3,  sn22,           sensorSONAR_inch)
#pragma config(Sensor, dgtl5,  sn33,           sensorSONAR_inch)
#pragma config(Sensor, dgtl10, ,               sensorTouch)
#pragma config(Motor,  port2,           right,         tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port3,           left,          tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port6,           handMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           handServo,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           servo1,        tmotorServoStandard, openLoop)
#pragma config(Motor,  port9,           motor1,        tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool hdown;
bool hopen;
bool line;
bool us;
bool Bleft;
bool Bright;
int servopos;
int dn;
int lineThreshold;
int servoOffsetAngle;
int rightangle;
int leftangle;
float s1;
float s2;
float s3;
float l1;
float l2;
float l3;
bool ll1;
bool ll2;
bool ll3;
bool ball;
string lin;
string linP;
int test;


void die(){

}




task main()
{
	hdown = false;
	hopen = false;
	Bright = true;
	Bleft = false;
	ball = false;
	servopos = 0;
	dn = 1;
	rightangle = 0;
	leftangle = -40;
	us = false;
	line = false;
	ll1 = false;
	ll2 = false;
	ll3 = false;
	lin = "010";
	linP = "010";
	lineThreshold = 2000;
	servoOffsetAngle = 60;
	test = 0;

	while(1 == 1)
	{
		//motor[light] = 100;
		l1 = SensorValue[L1];
		l2 = SensorValue[L2];
		l3 = SensorValue[L3];
		//-------------------------------Line_following-------------------------------//
		while(line == true){
			if(vexRT[Btn5D] == 1){
				if(line == true){
					line = false;
					delay(250);
					} else {
					line = true;
					delay(250);
				}
			}

			//resets string for holding line sensor values
			if(lin != "000"){
				linP = lin;
			}
			lin = "";

			l1 = SensorValue[L1];     //reads line sensor values
			l2 = SensorValue[L2];
			l3 = SensorValue[L3];

			if(l1>lineThreshold){     //sets the string based on the line sensor values
				lin += "1";
				} else {
				lin += "0";
			}
			if(l2>lineThreshold){
				lin += "1";
				} else {
				lin += "0";
			}
			if(l3>lineThreshold){
				lin += "1";
				} else {
				lin += "0";
			}

			int lineSteer = 100;
			int lineSteer2 = 55;
			int motorSpeed = 30;

			switch(atoi(lin)){     //deciding how to drive with a switch function
			case 000:
				//if none are on black, use previous line value
				
				test = 1;
				switch(atoi(linP)){
				case 001:
					motor[servo1] = (servoOffsetAngle+lineSteer2)*-1;
					motor[motor1] = motorSpeed;
					break;
				case 010:
					motor[motor1] = motorSpeed;
					motor[servo1] = (servoOffsetAngle)*-1;
					break;
				case 100:
					motor[servo1] = (servoOffsetAngle-lineSteer2)*-1;
					motor[motor1] = motorSpeed;
					break;
				}
				
				break;
			case 001:
				//go right//
				motor[motor1] = motorSpeed;
				motor[servo1] = (servoOffsetAngle+lineSteer)*-1;
				test = 2;
				break;
			case 010:
				//go forward//
				motor[motor1] = motorSpeed;
				motor[servo1] = (servoOffsetAngle)*-1;
				test = 3;
				break;
			case 011:
				//this should not happen
				test = 4;
				die();
				break;
			case 100:
				//go left//
				motor[motor1] = motorSpeed;
				motor[servo1] = (servoOffsetAngle-lineSteer)*-1;
				test = 5;
				break;
			case 101:
				//this should not happen
				test = 6;
				die();
				break;
			case 110:
				//this should not happen
				test = 7;
				die();
				break;
			case 111:
				//if this happens the universe is broken
				test = 8;
				die();
				break;
			default:
				test = 0;
				motor[motor1] = 0;
				break;
			}
			delay(50);
			motor[motor1] = 0;
			motor[servo1] = (servoOffsetAngle)*-1;
			//delay(25);

		}
		//-------------------------------End_Line_Following-------------------------------//

		//-------------------------------Ultrasonic-------------------------------//
		while(us == true){
			if(vexRT[Btn6U] == 1){
				us = false;
			}
			s1 = SensorValue[sn11];
			s2 = SensorValue[sn22];
			s3 = SensorValue[sn33];
			if(s1>=15.0 && s2>=15.0 && s3>=15.0){
				motor[motor1] = 73;
				motor[servo1] = -57;
				} else if(s2<=(s1||s3)){
				if(s1>=s3){
					motor[servo1] = -125;
					delay(15);
					motor[motor1] = -55;
					delay(350);
					}else{
					motor[servo1] = 25;
					delay(15);
					motor[motor1] = -55;
					delay(350);
				}
				}else if(s1>=s3){
				Bleft = true;
				Bright = false;
				motor[motor1] = 75;
				if(s3>=10.0){
					motor[servo1] = -75;
					} else if(s3>=8.0){
					motor[servo1] = -100;
					} else {
					motor[servo1] = -125;
				}
				} else if(s1<=s3){
				Bleft = false;
				Bright = true;
				motor[motor1] = 75;
				if(s1>=10.0){
					motor[servo1] = -25;
					} else if(s1>=8.0){
					motor[servo1] = 0;
					} else {
					motor[servo1] = 25;
				}
				motor[servo1] = 25;
			} 
			if(s1<=7.0 || s2<=7.75 || s3<=7.0){
				motor[motor1] = 0;
				if(right == true){
					motor[servo1] = -125;
					} else {
					motor[servo1] = 25;
				}
				delay(15);
				motor[motor1] = -55;
				delay(350);
			}
		}
		//-------------------------------End_Ultrasonic-------------------------------//

		//-------------------------------Joystick_Input-------------------------------//
		motor[servo1] = ((vexRT[Ch1] / 2)+servoOffsetAngle)*-1;
		if(vexRT[Btn5U] == 1){
			dn = 3;
			} else {
			dn = 1;
		}
		motor[motor1] = vexRT[Ch3]/dn;
		if(vexRT[Btn8L] == 1){
		}
		if(vexRT[Btn8R] == 1){
		}

		if(vexRT[Btn7U] == 1){
			motor[handServo] = 35;
			}else if(vexRT[Btn7D] == 1){
			motor[handServo] = -35;
			} else if(vexRT[Btn8U] == 1){
				motor[handServo] = 127;
			} else if(vexRT[Btn8D] == 1){
				motor[handServo] = -127;
			} else {
			if(ball){
				motor[handServo] = -12;
				} else {
				motor[handServo] = 12;
			}
		}

		if(vexRT[Btn7L] == 1){
			motor[handMotor] = 45;
			}else if(vexRT[Btn7R] == 1){
			motor[handMotor] = -35;
			} else {
			motor[handMotor] = 0;
		}

		if(vexRT[Btn6D] == 1){
			us = true;
		}
		if(vexRT[Btn5D] == 1){
			if(line == true){
				line = false;
				delay(250);
				} else {
				line = true;
				delay(250);
			}
		}
		if(vexRT[Btn6U] == 1){
			ball = true;
			} else {
			ball = false;
		}
	}
}
//-------------------------------End_Joystick_Input-------------------------------//




























/*
l1 = SensorValue[L1];
l2 = SensorValue[L2];
l3 = SensorValue[L3];
if(l1>lineThreshold){
ll1 = true;
} else {
ll1 = false;
}
if(l2>lineThreshold){
ll2 = true;
} else {
ll2 = false;
}
if(l3>lineThreshold){
ll3 = true;
} else {
ll3 = false;
}

//deciding how to drive

if(ll1){
motor[motor1] = -35;
motor[servo1] = rightangle;
right = true;
left = false;
} else if(ll2){
motor[motor1] = 35;
motor[servo1] = -20;
} else if(ll3){
motor[motor1] = 35;
motor[servo1] = leftangle;
right = false;
left = true;
} else if(right){
motor[motor1] = 35;
motor[servo1] = rightangle;
} else if(left){
motor[motor1] = 35;
motor[servo1] = leftangle;
} else {
motor[motor1] = 0;
motor[servo1] = 0;
}
*/
